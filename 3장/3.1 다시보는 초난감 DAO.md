초난감 DAO코드에 DI를 적용 
*	관심이 다른 코드를 다양한 방법으로 분리
*	확장과 변경에 용이하게 대응할 수 있는 설계구조로 개선하는 작업

객체지향 설계의 핵심 원칙 : 개방 패쇄 원칙 OCP 
**1. 변경을 통해 그 기능이 다양해지려고 확장하려는 성질을 가진 부분**
**2. 고정되어있고 변하지 않으려는 성질이 있는 부분**

으로 코드가 구분될 수 있음

> **템플릿 : 코드 중 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜 효과적으로 활용하기 위한 방법**

3장에서는 스프링에 적용된 템플릿 기법을 살펴보고, 이를 적용해 완성도 있는 DAO코드를 만드는 방법을 알아볼 것



* * *

# 3.1 | 다시 보는 초난감 DAO

* UserDao코드에 남아있는 문제점: 예외상황에 대한 처리

## 3.1.1 | 예외처리 기능을 갖춘 DAO

JDBC 코드는 DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작 

 **-> 어떤 이유로든 예외가 발생하면 사용한 리소스를 반드시 반환하도록 만들어야 함**
 
 
 * JDBC 수정 기능의 예외처리 코드

 > JDBC API를 이용한 DAO 코드인 deleteAll()
- PreparedStatement를 처리하는 중 예외 발생한다면 메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나감
- Connection과 Preparedstatement의 close()메소드가 실행되지 않아 제대로 리소스 반환되지 못함
- 치명적인 위험 내포
 
 <pre><code>public void deleteAll() throws SQLException{
	Connection c = dataSource.getConnection();
	
	//여기서 예외가 발생하면 바로 메소드 실행이 중단
	PreparedStatement ps = c.prepareStatement(“delete from users”);	
	ps.executeUpdate();

	ps.close();
	c.close();
}</code></pre> 

* * *
### try/catch/finally 구문의 사용 권장
어떤 상황에서도 가져온 리소스를 반환할 수 있도록 하기 위함

> 예외 발생 시에도 리소스를 반환하도록 수정한 deleteAll()
<pre><code>
public void deleteAll() throws SQLException {
	Connection c = null;
	PreparedStatement ps = null;
		try {
		c = dataSource.getConnection();
		ps = c.prepareStatement(“delete from users”);
		} catch (SQLException e) {
		throw e;
		} finally {
		if (ps != null) { try { ps.close(); } catch (SQLException e) { } }//if
		if (c != null) { try { c.close(); } catch (SQLException e) }//if
		}//finally
}//deleteAll()
</code></pre>
* * *

# 3.2 | 변하는 것과 변하지 않는 것
## 3.2.1 | JDBC try/catch/finally 코드의 문제점
* 문제 상황: 복잡한 try/catch/finally 블록이 2중으로 중첩, 모든 메소드마다 반복
> solution: 
> 1. Copy&Paste)  실수가능성 결국 똑같이 위험 초래 – 폭탄의 가능성
> 2. Test) 적용이 어려움, 테스트코드의 양이 엄청나게 늘어날 것
> 3. **변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 확장되고 변하는 코드 분리**

## 3.2.2 | 분리와 재사용을 위한 디자인 패턴 적용
* 성격이 다른 것을 찾아내기

> 개선할 deleteAll() 메소드
변하는 부분이라는 명시된 부분을 제외하고는 PreparedStatement를 만들어서 업데이트용 쿼리를 실행하는 메소드들 끼리 비슷한 구조. 
add() 메소드를 살펴보면 확인 가능.
<pre><code>
public void deleteAll() throws SQLException {
		Connection c = null;
		PreparedStatement ps = null;
		try {
			c = dataSource.getConnection();
			ps = c.prepareStatement(“delete from users”); //변하는 부분
} catch (SQLException e) {
	throw e;
}
</code></pre>

* IDEA ) 변하는 / 변하지 않는 분리
* 변하지 않는 부분 재사용 할 수 있는 방법?
* * *
### 메소드 추출
변하는 부분을 메소드로 빼기

> 변하는 부분을 메소드로 추출한 후의 deleteAll()
하지만 이 경우 변하지 않는 부분을 메소드로 추출 : 이득 없어보임
<pre><code>
public void deleteAll() throws SQLException {
		//. . .
		try {
			c = dataSource.getConnection();
			ps = makeStatement(c);
			ps.executeUpdate();
		} catch (SQLException e) {
		//. . .
		}

	private PreaparedStatement makeStatement(Connection c) throws SQException {
		preparedStatement ps;
	ps = c.prepareStatement(“delete from users”);
	return ps;
	}
</code></pre>


### 템플릿 메소드 패턴을 적용한 분리
* 템플릿 메소드 패턴: 상속을 통해 기능을 확장해서 사용하는 부분
변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래서에서 오버라이드하여 새롭게 정의해 쓰도록 함

> 추출해서 메소드로 독립시킨 makeStatement() 메소드를 추상 메소드 선언으로 변경
> -> UserDao 클래스도 추상 클래스가 됨
<pre><code>
abstract protected PreparedStatement makeStatement(Connection c) throws
		SQLException;
</code></pre>
이를 상속하는 서브 클래스 만들어 makeStatement() 메소드 구현
* “JDBC try/catch/finally 블록을 가진 슈퍼클래스 메소드와 필요에 따라 상속을 통해 구체적인 PreparedStatement를 바꿔서 사용할 수 있게 만드는 서브클래스로 분리

> makeStatement()를 구현한 UserDao 서브클래스
> * 상속을 통해 UserDao 클래스의 자유로운 기능 확장 가능
> * 확장 때문에 생기는 기존의 상위 DAO 클래스에 불필요한 변화 막음
<pre><code>
public class UserDaoDeleteAll extends UserDao {
		protected PreparedStatement makeStatement(Connection c) throws SQLException 
			{ 
			PreparedStatement ps = c.prepareStatement(“delete from users”);
			return ps;
			}
}
</code></pre>

* 문제점) 템플릿 메소드 패턴으로의 접근은 제한이 많음
-	DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 함 -> **UserDao의 JDBC메소드가 4개일 경우 4개의 서브클래스 만들어야 함**
-	확장구조가 이미 클래스를 설계하는 시점에서 고정됨. 컴파일 시점에서 관계가 설정되어 유연성이 떨어짐

### 전략패턴의 적용
* 전략 패턴) 오브젝트를 아예 둘로 분리 -> 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만든다
= 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식 ?

<그림 첨부>
: Context의 contextMethod() 에서 일정한 구조를 가지고 동작하다가 특정 확장 기능은 Strategy 인터페이스를 통해 외부의 독립된 전략 클래스에 위임.

#### deleteAll()메소드로 전략패턴의 적용 이해해보기
* 변하지 않는 맥락-context ) JDBC를 이용해 DB 업데이트 하는 작업
> -	DB 커넥션 가져오기
> -	PreparedStatement를 만들어줄 외부 기능 호출하기
> -	전달받은 PreparedStatement 실행하기
> -	예외가 발생하면 이를 다시 메소드 밖으로 던지기
> -	모든 경우에 만들어진 PreparedStatement와 Connection을 적절히 닫아주기


* 전략-strategy ) PreparedStatement를 만들어주는 외부기능 
> PreparedStatement를 만드는 외부기능을 인터페이스로 만들어두고 인터페이스의 메소드를 통해 PreparedStatement 생성 전략을 호출
> 주의! context에서 만들어둔 DB커넥션이 없으면 PreparedStatement도 만들수 없기 때문에 생성전략을 호출할 시에는 커넥션을 전달해야 함

* 인터페이스 만들기
> StatementStrategy 인터페이스
> - 위의 PreparedStatement를 만드는 전략의 인터페이스는 컨텍스트가 만들어준 Connection 전달받아서, PreparedStatement를 만들고 만들어진 PreparedStatement 오브젝트를 돌려준다
<pre><code>
package springbook.user.dao;
// . . .
public interface StatementStrategy {
	PreparedStatement makePreparedStatement(Connection c) throws SQLException
}
</code></pre>







